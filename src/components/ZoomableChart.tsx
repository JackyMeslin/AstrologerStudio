'use client'

import { useCallback, useEffect, useMemo, useRef, useState } from 'react'
import clsx from 'clsx'
import { Button } from '@/components/ui/button'
import { useChartGestures, type TransformState } from '@/hooks/useChartGestures'

/**
 * Props describing the chart markup and optional behaviour tuning.
 * @property html Raw HTML generated by the astrology engine (typically an SVG string).
 * @property className Optional styling forwarded to the outer container.
 * @property minScale Smallest zoom level permitted when the user zooms out.
 * @property maxScale Largest zoom level permitted when the user zooms in.
 */
type ZoomableChartProps = {
  html: string
  className?: string
  minScale?: number
  maxScale?: number
}

// Semantic constants for zoom and comparison thresholds
const DEFAULT_MIN_SCALE = 0.75
const DEFAULT_MAX_SCALE = 5
const DEFAULT_SCALE = 1
const BUTTON_ZOOM_FACTOR = 1.2
const SCALE_COMPARISON_THRESHOLD = 0.001
const TRANSLATION_COMPARISON_THRESHOLD = 0.5
const PAN_ENABLED_SCALE_THRESHOLD = 1.05 // Pan only enabled when zoomed in past this threshold

/**
 * Keep a numeric value within the provided range.
 */
const clamp = (value: number, min: number, max: number): number => {
  if (value < min) return min
  if (value > max) return max
  return value
}

/**
 * Basic validation to ensure the HTML content is safe and not empty.
 * This is a basic check; the actual HTML should be sanitized server-side.
 */
const isValidHtml = (html: string): boolean => {
  return typeof html === 'string' && html.trim().length > 0
}

/**
 * Interactive container that renders chart markup and adds wheel, pinch and drag gestures.
 * - `html` should be trusted markup (server rendered SVG) that will be injected verbatim.
 * - Zoom can be controlled by wheel, pinch, or the +/- controls.
 * - Panning uses pointer events so both mouse drag and touch drag work.
 */
export function ZoomableChart({
  html,
  className,
  minScale = DEFAULT_MIN_SCALE,
  maxScale = DEFAULT_MAX_SCALE,
}: ZoomableChartProps) {
  // DOM refs used for event wiring and to read layout boxes during gestures.
  const containerRef = useRef<HTMLDivElement | null>(null)
  const contentRef = useRef<HTMLDivElement | null>(null)
  // Live transform state: zoom, transform origin, and panning offset.
  const [scale, setScale] = useState(DEFAULT_SCALE)
  const [translation, setTranslation] = useState({ x: 0, y: 0 })

  // Track live transform values during gestures (for smooth 60fps without React re-renders)
  const liveTransformRef = useRef<TransformState>({ scale: DEFAULT_SCALE, x: 0, y: 0 })

  /**
   * Return the chart to its original size and location and clear any active pointer captures.
   */
  const resetView = useCallback(() => {
    setScale(DEFAULT_SCALE)
    setTranslation({ x: 0, y: 0 })
    liveTransformRef.current = { scale: DEFAULT_SCALE, x: 0, y: 0 }
  }, [])

  // Any time the incoming markup changes we want to drop accumulated transforms.
  useEffect(() => {
    resetView()
  }, [html, resetView])

  // Keep synchronous references to the latest values so event handlers can read them.
  useEffect(() => {
    liveTransformRef.current.x = translation.x
    liveTransformRef.current.y = translation.y
  }, [translation])

  useEffect(() => {
    liveTransformRef.current.scale = scale
  }, [scale])

  // Use the composed gesture handling hooks
  useChartGestures(containerRef, contentRef, liveTransformRef, { minScale, maxScale }, setScale, setTranslation)

  // Determine whether the chart is perfectly reset so we can hide/show the reset button.
  const isDefaultView = useMemo(() => {
    const isDefaultScale = Math.abs(scale - DEFAULT_SCALE) < SCALE_COMPARISON_THRESHOLD
    const isDefaultX = Math.abs(translation.x) < TRANSLATION_COMPARISON_THRESHOLD
    const isDefaultY = Math.abs(translation.y) < TRANSLATION_COMPARISON_THRESHOLD
    // Float comparisons are fuzzy because transforms accumulate minor rounding errors.
    return isDefaultScale && isDefaultX && isDefaultY
  }, [scale, translation.x, translation.y])

  const isZoomedIn = scale > PAN_ENABLED_SCALE_THRESHOLD

  /**
   * Programmatic zoom controls (used by the +/- buttons).
   * The factor mirrors the 20% granularity commonly found in map applications.
   */
  const handleZoom = useCallback(
    (direction: 'in' | 'out') => {
      const factor = direction === 'in' ? BUTTON_ZOOM_FACTOR : 1 / BUTTON_ZOOM_FACTOR
      setScale((previous) => clamp(previous * factor, minScale, maxScale))
    },
    [maxScale, minScale],
  )

  // Validate HTML content
  if (!isValidHtml(html)) {
    return (
      <div className={clsx('flex items-center justify-center p-8 text-muted-foreground', className)}>
        <p>Invalid or empty chart data</p>
      </div>
    )
  }

  return (
    <div
      ref={containerRef}
      className={clsx(
        'select-none relative will-change-transform overflow-x-visible md:overflow-y-visible overflow-y-clip',
        // Initial state handled by CSS, dynamical updates by direct manipulation for perf
        isZoomedIn ? 'touch-none' : 'touch-manipulation',
        'cursor-grab', // Default cursor, grabbing is handled via style manipulation
        className,
      )}
      role="region"
      style={{ touchAction: isZoomedIn ? 'none' : 'manipulation' }} // Inline style as fallback base
      aria-label="Zoomable astrology chart"
    >
      {/* Floating controls: reset appears only when needed, zoom controls stay always available. */}
      <div
        className="absolute right-0 bottom-4 lg:bottom-auto lg:top-0 z-10 flex items-end lg:items-start gap-2"
        data-zoom-interactive
        role="toolbar"
        aria-label="Chart controls"
      >
        {!isDefaultView ? (
          <Button
            size="sm"
            variant="outline"
            className="shadow bg-background/80 backdrop-blur-sm hover:bg-background/90"
            onClick={resetView}
            aria-label="Reset chart view to default"
          >
            Reset view
          </Button>
        ) : null}
        <div
          className="flex h-8 items-stretch rounded-md border border-input bg-background/80 backdrop-blur-sm shadow"
          role="group"
          aria-label="Zoom controls"
        >
          <Button
            size="sm"
            variant="ghost"
            className="h-full rounded-none px-3 text-base first:rounded-l-md border-r border-input hover:bg-background/90"
            onClick={() => handleZoom('in')}
            aria-label="Zoom in"
            title="Zoom in (or use mouse wheel)"
          >
            +
          </Button>
          <Button
            size="sm"
            variant="ghost"
            className="h-full rounded-none px-3 text-base last:rounded-r-md hover:bg-background/90"
            onClick={() => handleZoom('out')}
            aria-label="Zoom out"
            title="Zoom out (or use mouse wheel)"
          >
            -
          </Button>
        </div>
      </div>
      <div
        ref={contentRef}
        className="w-full max-w-full origin-top-left md:overflow-y-visible"
        // We use inline styles for the initial render, but subsequent updates happen via direct DOM manipulation
        style={{
          transform: `translate(${translation.x}px, ${translation.y}px) scale(${scale})`,
          transformOrigin: '0 0', // Fixed origin, we handle the visual origin via translation math
        }}
        role="img"
        aria-label="Astrology chart visualization"
        dangerouslySetInnerHTML={{ __html: html }}
      />
    </div>
  )
}

export default ZoomableChart
